# **The Log-Structured Merge-Tree (LSM-Tree)**
Patrick O'Neil, Edward Cheng
Dieter Gawlick, Elizabeth O'Neil

## **ABSTRACT**

在历史表中插入行和生成日志都是为了系统恢复而做的常见准备，这两者都可以加速索引，但在普通的索引结构，例如B树中进行这些操作会使得I/O开销加倍，提高50%的整体系统开销。LSM tree是一种disk-based数据结构，专门用于提供低开销的文件索引，特别是对于记录插入很频繁的文件。LSM tree会推迟并且成批处理索引变化，使用的方式类似合并排序。LSM tree更适合索引插入多于索引查询的应用。

## **Introduction**

随着长期事务的出现，给事务日志提供索引成为了必备。传统日志关注于abort和recovery，recovery由成批的序列读实现。但随着事务越来越复杂，有时也需要实时查看过去的事务步骤，同时，活跃事件也逐渐增加到使得留在内存中的数据结构不够用。

**The Five Minute Rule**

当页访问频率超过每60秒一次时，增加内存空间，使得所有页都进入内存可以减少系统开销。
LSM-tree方法使得频繁的索引插入需要的磁盘旋臂使用更少，从而大大降低开销。
LSM-tree使用的推迟索引变化的算法是根本，在LSM-tree的很多情况下都被使用，除去插入，LSM-tree也支持删除和更新操作，对于长延迟的查找操作也支持。只有需要立即放回结果的查找操作会带来较大开销。

## **The Two Component LSM-Tree Algorithm**

LSM-tree由两个或更多树状的数据结构组成。
有两个组成部件的LSM-tree包含一个较小的部件，这个部件完全在内存中，被称作C0 tree，另一个较大的部件位于磁盘中，被称作C1 tree，C1的大部分节点也会被缓存在内存中，所以C1的常用部分也可以被算作位于内存中。

![图1](https://img-blog.csdnimg.cn/8ee5345ca02547ec83dda3157760b652.jpeg#pic_center)

每当生成一个历史记录，这个日志记录会被先写入序列日志文件，索引入口之后会被插入C0 tree，之后再迁移到C1 tree中，查找时先查找C0再查找C1。
在C0 tree中插入没有I/O开销，但C0的容量有限，因此当C0的容量到达阈值时，会执行一个rolling merge操作，从C0中删除一些相邻记录，并将记录合并入C1 tree。


![图2](https://img-blog.csdnimg.cn/ecc32a76ed454105bae2b8926531439c.jpeg#pic_center)

C1 tree有一个类似B树的字典结构，但顺序访问性能更好，节点全满，而且每层有一个单页节点序列号，一起放在根节点下面，与多页磁盘块相邻，用于旋臂查询。
Rolling merge操作是一系列的merge steps，读C1中的多页块可以获得在缓存中的索引入口，每个step会将块中的节点读出，与C0中取出的索引合并，在C1中创造新的叶节点。合并前包含C1叶节点的块称为emptying block，新的叶节点会被写入不同的块，叫做filling block。当一个filling block写满后，会被写入到磁盘的一块新空间。
新块被写入后，旧块不会被覆盖。C1的字典节点也会更新，但会尽量推迟来减少I/O，更新完毕后，C1中的旧叶节点会被删除，不再有效。合并的C1 tree会有剩余的叶级条目，合并后的新块也会有数个节点依然包含在缩减块中的索引条目，这些剩余的条目不会被写入磁盘。

**How a Two Component LSM-tree Grows** 

C0 tree不需要有类似B树的结构，C0 tree中的节点可以是任意大小，当C0 tree的大小第一次到达阈值时，最左边的条目序列会被一次性批量删除，然后被重组到C1 tree中，连续的叶节点中的数据会被从左到右依次在缓存块中被放置，直到块满，之后这个块会被写入磁盘，变成C1 tree的磁盘中叶级的第一部分，当连续的叶节点被添加后，C1 tree的字典节点会被创建在内存中。
为了使C0 tree的大小不超出阈值，C1 tree的叶级连续多页块会以逐渐增加的序号顺序写入磁盘中。C1 tree的上层字典节点被保持在分散的多页块缓存中或单页缓存中，取决于开销情况。目录节点中的条目包含分离器，可以引导到单独的单页节点中，这样可以在叶级提供高效的单页索引节点精确匹配，避免多页块读，降低内存需求。因此，当长距离查询时或进行rolling merge时需要对多页块进行读或写，在进行索引查找访问时访问单页节点。
当以下情况发生时，C1的目录节点会被移动到磁盘的新位置：
1、包含目录节点的多页块满了
2、根节点被分割，C1 tree的深度增加
3、执行一个检查点
第一种情况时，满了的多页块被写入磁盘，后两者情况下，所有的多页块缓存和目录节点都被写入磁盘。
当C0 tree的最右边的条目也被写入C1 tree后，上述过程在C0和C1的左端重新开始，但是现在C1的多页块必须被读入缓存，与C0中的条目合并然后再创建新的C1多页块并写入磁盘。

合并时，C1 tree所有需要被合并的块会被分成两种，一种是emptying block，条目已经被清空，但仍保留着未被合并指针触及到的信息，一种是filling block，反映当前合并的情况。为了并行访问，两种块在每层都包含整数个C1 tree的页大小的节点，这些节点都位于内存中。当需要将所有缓冲节点刷入瓷盘时，每层的所有缓存信息都必须写入到磁盘的一个新的位置。之后，当缓存中的filling block被填满且需要再次刷入磁盘时，这个块会被写入新的位置。系统恢复可能需要的信息不会被覆写，只会在更新完成后无效。





## **Conclusions** 


B树在内存中缓存常用的目录节点，因此是结合了低成本磁盘存储介质和高成本的内存访问，其中大部分数据存于磁盘，最常用的数据存于内存。LSM-tree把这种分层结构扩展到多层，并且在执行多页磁盘读时结合了合并的优点。

![图3](https://img-blog.csdnimg.cn/b2a5109da1224be9b689d198fe82aef2.jpeg#pic_center)


从图中可以看出，LSM-tree减少了插入和删除这种可合并操作的访问开销，与冷数据的访问开销几乎相同。